# -*- mode: org;-*-
* TODO reuse the same parser with binary, octal, decimal and hex lexers;
  specialize the parser by lexer and radix (for string -> number
  conversion).
* TODO override exactness when octothorpes are present
* TODO shouldn't integer(), rational(), imaginary(), etc. take over the
  burden of composite exactness?
* TODO here we are, dealing with types and promotion again; sticky; and
  weren't there unpromotables?
* TODO it turns out the exactness of the real and imaginary parts
  are orthogonal; the composite exactness in conjunctive.
* TODO the imaginary part has an imaginary part, oddly, of NaN;
  only way to solve the recursion might be to formalize
  imaginary_numerator, imaginary_denominator.

  have to have an imaginary_exactness, though; why not number as a
  composite of rationals + production

  fuck it: it will be a special case; what, on the other hand, if we
  want to do arithmetic on the imaginary part? it's a defective
  number.

  the trouble is, really, that the imaginary part itself has an
  imaginary part (though possibly nullary)

  we could define real as the case in which complex part is 0 or NaN,
  but then we have to special-case all of the operations.

  could we define zero as some sort of infinite production?

  yes: define a fucking imag_part function which special cases
  imaginary NaN as zero.

  the operations take care of the imaginary -> real; still ad hoc
  though; would have to be painfully generalized for quaternions. fuck
  it.
* TODO if i want to stray from a unified number system for optimization,
  though, going to have to juggle types myself; or resort to native
  objectivism.
* TODO a tolerance/precision is required when invoking an irrational, such
  that it becomes a rational when actualized.

  pi as (* 4 (atan 1)) until actualized.
* DONE r5rs 6.2.5: "the denominator of 0 is defined to be 1"
  CLOSED: [2009-05-19 Tue 00:05]
  - CLOSING NOTE [2009-05-19 Tue 00:05] \\
    zero()
* TODO r5rs 6.2.5: "the denominator is always positive"
* TODO you'll still have a radix non-terminal even if it's blank
* TODO the gradual parsing of number information: exactness before uinteger
  before sign, is why i'd like to have a unified number type that
  responds to type queries computationally.

  It would therefore have numerator, denominator, imaginary part;
  which may or may not be nullary. Imaginary part itself a Number.
* TODO honest irrational numbers with production functions and
  no bound on precision
* TODO kleene star can't be done in lexer, it seems; endless loop on
  blank string.
* TODO there is some ambiguity between UREAL_10 qua UINTEGER_10 and
  DECIMAL_10 qua UINTEGER_10 + nullary SUFFIX
* TODO it may well be profitable to delay the creating of schemelike
  structures as long as possible (may not be able to delay them beyond
  the parser, though: exactness, etc.)
* TODO holy shit! lexers can follow the lexical formalisms
  more or less verbatim!
** TODO does the parser admit of states? or do i have to have
   an ad-hoc parser that corresponds to each lexer state?
* TODO [#A] integrate decimal last? seems to be a weird case
** TODO in particular, handle other numbers first; might be able
   to combine them into one number parser
* TODO identify problematic things (like decimal) in the lexer;
  have a subparser to handle it.
* TODO could have a separate number parser with special cases
  for E, S, F, D, L, etc.; wonder if that can be simulated with
  states?
* TODO every non-terminal a test?
* TODO parser tests: all the samples from r5rs?
* TODO why not do the scheme conversion at the last minute,
  so as to be able to manipulate value, sign, etc. efficiently?
* TODO jumped the gun on the exactness question (wait for
  prefix)
* TODO should the stack_to_* function return actual scheme
  values
* TODO becaus we're not using complex regexps in the lexer,
  we might have to use states to distinguish between #e10 the
  exponent, and #e the exact sign.
* TODO move utilities such as map into their own file (not pair)
* TODO non-terminals to have a label?
* TODO we can signify somewhere in the parser that a datum has
  been read; then the lexer can stop taking from the input stream.
* TODO might need an identifier/class for each of the non-terminals
* TODO generate the fucking parse tree; not this worthless embedded
  stack shit.
* TODO sig figs may be worthless; but what about an uncertainty
  parameter?
* TODO do math with gmp ints and exponents? but why not then just
  implement the damn float libs?
* TODO either create containers for digits/octothorpes or sentinels
  to mark having seen a digits{0}.
* TODO can possibly call a yy_*() function after parsing a <datum>?
* TODO how do we want to represent numbers: 1 <= x < 2 plus exponent?
* TODO there seem to be rigorous boundaries to groups delineated
  by digits{0}, octothorpes{0}, etc. Hmm; digit never seems to get
  matched with recursive rules around. (Because digit is decomposed
  into terminals.)
* TODO is there a systematic way to delegate lexer/parser
  responsibilities?

  i could at least enlist regular expressions to take care of + and *,
  couldn't I? otherwise, the gathering is laborious.
* TODO do we need the level of indirection of JLexToken, or how else
  gather type + value?
* TODO things tokenized have to been resynthesized in the parser;
  non-terminal, specifically, should gather preceding terminals?
  Otherwise, decimal, for instance, would have aware of exponents,
  signs, etc.

  Don't really gain any advantage over complex regular expressions in
  the parser which have to be unsynthesized post-hoc: still have to
  assemble the digit/octothorpe soup in the stack, for instance, and
  segregate.
* TODO some things like . <digit 10>+ #* <suffix> trivial with regular
  expressions; not so much with formal grammars; make exceptions for
  complex expressions in the lexer, decompose in the parser?
* TODO parser only really cares about identifier, boolean, number,
  character, string from lexical analysis (some delimiters here and
  there). Really, only cares about tokens. Can do all the token work
  in the lexer; percolate up tokens to the parser?
* TODO looks like we could also leave the parser bare, and do all the object
  generation in the lexer; that way, we can propagate abstracta to the
  parser.

  as long as i have macros, can do some abstraction in the lexer; use
  parser for verification?
* TODO actually: since we're merely generating php, we can do the lexing
  and parsing in any fucking language we want: haskell, scheme, etc.;
  add a php driver.

  oh, fuck; it's nice to have good tools. thanks, wez furlong.
* TODO my main problem has to do with the contextual parsing of overlapping
  atoms; i is a letter in one context, but signifies imaginary in
  another; set up states?

  even if i have sloppy grouping (complex R, for instance), and have
  to do another round of parsing to extract its...

  fuck it; we're going back to: lexer: terminals; parser:
  non-terminals, no matter how painful the non-terminals are in BNF.
** TODO one rule to seed each recursion; another to recurse.
** TODO can overload tokens, too: DIGIT token whose value can be: 0, 1, ...;
   nope: have to distinguish between 1: binary, octal, decimal, hex;
   7: octal, decimal, ...
** TODO getting indeterminacy; can do arbitrarily complex regexps
   for the first pass, and employ secondary parsers to deal with, say,
   numbers.
* TODO (parser) taking care of most of the complexity via regexps in the lexer
  is probably quicker, even though it's less readable.
* TODO worry about number precision via GMP? http://us3.php.net/gmp
** php's GMP doesn't do floats
* TODO unified function that parses and evaluates; fuck the class: sphuck()
** TODO one for files, too: load() or fsphuck() or something
* DONE recursive closures
  CLOSED: [2009-04-13 Mon 01:18]
  - CLOSING NOTE [2009-04-13 Mon 01:20] \\
    thanks, Justin Martin; http://marc.info/?l=php-internals&m=123960965909314&w=2
* TODO some sort of evaluator instantiation a la class?
* TODO error() should catch the errors from within scheme; to allow for
  error catching, etc.; but also: no reason to bail out on the
  interpreter on account of a php error.
* DONE either find a way to apply values from scheme, or have a set of
  primitive procedures (primitive_car, primitive_add, ...) that take a
  scheme-list of values. alternatively, scheme_value_to_array and
  call_user_func_array. on the other hand: breaks the immediate
  scheme->php function-name mapping (important?).
  CLOSED: [2009-04-12 Sun 22:06]
  - CLOSING NOTE [2009-04-12 Sun 22:06] \\ decided on orthogonal
    primitive_* functions for now; benchmark with value->array
    application?
** TODO nope: every time we get a value, it's wrapped in a list; simple
   list->array should suffice for value unpacking, regardless of
   contained types.
* TODO scheval handles as special cases things that could be macroized:
  quote, unquote, if, cond, etc.
* TODO a read that stops after one expression
** TODO may be able to modify parse() to stop after encountering a <datum>
* TODO name-munging and resort to primitive procedures without needing
  to register them in $primitive_procedures?
* TODO some mechanism for translating scheme values to php
* TODO parser persistance with read()?
* TODO general scheme file for things like type predicates, map,
  equality, etc.?
* DONE [#A] symbol() function that memoizes symbols?
  CLOSED: [2009-04-12 Sun 13:42]
  - CLOSING NOTE [2009-04-12 Sun 13:42]
** DONE each type to have memoizing constructor: Boolean -> boolean(),
   CLOSED: [2009-04-12 Sun 13:41]
   - CLOSING NOTE [2009-04-12 Sun 13:42] \\
     not yet char, vector, pair; but lst
   String -> string(), Number -> number(), Char -> char(), Vector ->
   vector(), ...? What about Pair -> pair(): immutable pairs?
* TODO implement the solved exercises as opposed to feral book.
* DONE TRUE and FALSE singletons?
  CLOSED: [2009-04-12 Sun 13:42]
  - CLOSING NOTE [2009-04-12 Sun 13:42] \\
    global $true/$false, as well as boolean() memoization
* TODO some things made more elegant: dispatch on type, etc.; inner
  functions.
* TODO might need an actual Nil type so we can do things like
  is_eq(Nil, Nil) by dispatching on class.
* TODO distinguish between constants created with QUOTE and constructed
  values?
* CANCELED why make an exception for the schemish COND and IF, if includeth
  CLOSED: [2009-04-12 Sun 13:43]
  - CLOSING NOTE [2009-04-12 Sun 13:43] \\
    distinguish between working with quasi-scheme in php and scheme
  CONS, etc.? control structures are superfluous?
* DONE quote mechanism is mysterious: quote(<string>) -> symbol;
  quote(<number>) -> number; quote(<list>) -> list; quote(<vector>) ->
  vector? problem is: quote(<string>) -> string; no way to distinguish
  between symbols and strings in php except with recourse to their
  quasi-scheme types.
  CLOSED: [2009-04-13 Mon 01:08]
  - CLOSING NOTE [2009-04-13 Mon 01:18] \\ quote can be implemented in
    scheme (as a macro?) or an interpreter extension to avoid the
    string/symbol ambiguity
* DONE write a quasi-scheme in PHP, such that the metacirc runs almost
  unaltered; may be slower than some PHP-centric strategy, but sphuck
  it!
  CLOSED: [2009-04-12 Sun 13:43]
  - CLOSING NOTE [2009-04-12 Sun 13:44] \\
    did indeed that; may opt for machine later a la ch. 5?
* DONE environments with non-destructive merging
  CLOSED: [2009-04-12 Sun 13:44]
  - CLOSING NOTE [2009-04-12 Sun 13:44] \\
    for free with metacirc
* TODO type stack with numbers (imaginary component; how to distinguish
  between exact (rational: num/denom) and inexact (float): subclasses
  of number? does each (exact, inexact) have imaginary components?)
* TODO use r5rs 7.1 to inform the lexer/parser; we're lacking booleans,
  vectors, etc.
* TODO README
* TODO sphuck namespace for lexer/parser
