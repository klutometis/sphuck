<?php

class Lexer implements Iterator {
  public $data;
  public $token;
  public $value;
  public $line;
  public $old_count;
  public $count;

  function __construct($data) {
    $this->data = $data;
    $this->old_count = -1;
    $this->count = 0;
    $this->line = 1;
  }

  function rewind() {
    $this->__construct($this->data);
    $this->next();
  }

  function current() {
    return $this->value;
  }

  function key() {
    return $this->token;
  }

  function next() {
    $this->old_count = $this->count;
    $this->yylex();
    return $this->value;
  }

  function valid() {
    return $this->old_count != $this->count;
  }

// matching \n probably won't work; might need some lookahead in cases
// where or mixes tokens of multiple lengths (string, character); have
// to handle interpretation of escape chars in the parser?

// need terminals here in the narrow sense; otherwise, delimiter/token
// will conflict over ( and ). that's the parser's job.

// lexer can process non-terminal one level deep? we could do
// <atmosphere> -> <whitespace> | <comment> here, for instance

// how do we deal with the fact that e, s, f, d, l and both exponent
// markers and letters; they'll lex as an arbitrary rule; or can we
// combine rules? hmm: letter takes precedence over exponent_marker,
// whether first or last.

// make the suffix rule a complex reg that only matches the
// combination of terminals

// shit: how to modify the regexps to be non-case sensitive; all the
// fucking identifiers are going to be case-sensitive: /.../i doesn't
// work; /(?i).../ doesn't work. not really pregs, then. fuck: it's
// doing it's own regex parsing; bastard.

// going to have to capture the lexemes with complex regexps; keywords
// will still be case sensitive, though

// or maybe a reasonable granularity are the tokens

// ignore case sensitivity for now; assume we have to modify lexer to
// account for it

// use lexer as a strict terminal -> token mechanism

// instead of sed on the resultant php, allow modifiers through:
// imsxUX: /.../[imsxUX]

// letter = /[a-zA-Z]/
// letter {
//   $this->token = Parser::LETTER;
// }

/*
octothorpe = /\#/
octothorpe {
  $this->token = Parser::OCTOTHORPE;
}
*/
// find expressions for {{+,-},ureal} in the various bases; digest
// complex into eight parts per base plus +i -i for all bases
// (positive_imaginary, negative_imaginary)

/*!lex2php
%input $this->data
%counter $this->count
%token $this->token
%value $this->value
%line $this->line
zero = /0/
*/

/*!lex2php
zero {
  $this->token = SPHUCK_ZERO;
}
*/
}

function token_array($lexer) {
  $tokens = NULL;
  foreach ($lexer as $token => $value)
    $tokens[] = array($token => $value);
  return $tokens;
}
