<?php

class Lexer implements Iterator {
  const OPEN = 1;
  const CLOSE = 2;
  const NUMBER = 3;
  const SYMBOL = 4;
  const STRING = 5;
  const DOT = 6;
  const QUOTE = 7;
  const QUASIQUOTE = 8;
  const UNQUOTE = 9;
  const UNQUOTE_SPLICING = 10;

  public $data;
  public $token;
  public $value;
  public $line;
  public $old_count;
  public $count;

  function __construct($data) {
    $this->data = $data;
    $this->old_count = -1;
    $this->count = 0;
    $this->line = 1;
  }

  function rewind() {
    self::__construct($this->data);
  }

  function current() {
    return $this->value;
  }

  function key() {
    return $this->token;
  }

  function next() {
    $this->old_count = $this->count;
    $this->yylex();
    return $this->value;
  }

  function valid() {
    return $this->old_count != $this->count;
  }

// Don't forget ,@ (not in perl sexp?)

/*!lex2php
%input $this->data
%counter $this->count
%token $this->token
%value $this->value
%line $this->line
atmosphere = /\s+/
number = /([+-]?\d+(?:[.]\d*)?|[+-]?[.]\d+)/
symbol = /[*!\$[:alpha:]\?<>=+:_\{\}\/-]([*!\$[:alpha:]\?<>=+:_\{\}\/-]|\d|[.])*/
string = /\"([^\"\\]*(?:\\.[^\"\\]*)*)\"/
open = /\(/
close = /\)/
dot = /[.]/
quote = /\'/
quasiquote = /\`/
unquote = /\,/
unquote_splicing = /\,\@/
*/

/*!lex2php
atmosphere {
  return false;
}
number {
  $this->token = Lexer::NUMBER;
}
symbol {
  $this->token = Lexer::SYMBOL;
}
open {
  $this->token = Lexer::OPEN;
}
close {
  $this->token = Lexer::CLOSE;
}
string {
  $this->token = Lexer::STRING;
  $this->value = $yy_subpatterns[0];
  $this->count += 2;
}
dot {
  $this->token = Lexer::DOT;
}
quote {
  $this->token = Lexer::QUOTE;
}
quasiquote {
  $this->token = Lexer::QUASIQUOTE;
}
unquote {
  $this->token = Lexer::UNQUOTE;
}
unquote_splicing {
  $this->token = Lexer::UNQUOTE_SPLICING;
}
*/
}

function token_array($lexer) {
  $tokens = NULL;
  foreach ($lexer as $token => $value)
    $tokens[] = array($token => $value);
  return $tokens;
}
