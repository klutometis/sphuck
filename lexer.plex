<?php

class Lexer implements Iterator {
  public $data;
  public $token;
  public $value;
  public $line;
  public $old_count;
  public $count;

  function __construct($data) {
    $this->data = $data;
    $this->old_count = -1;
    $this->count = 0;
    $this->line = 1;
  }

  function rewind() {
    $this->__construct($this->data);
    $this->next();
  }

  function current() {
    return $this->value;
  }

  function key() {
    return $this->token;
  }

  function next() {
    $this->old_count = $this->count;
    $this->yylex();
    return $this->value;
  }

  function valid() {
    return $this->old_count != $this->count;
  }

// matching \n probably won't work; might need some lookahead in cases
// where or mixes tokens of multiple lengths (string, character); have
// to handle interpretation of escape chars in the parser?

// need terminals here in the narrow sense; otherwise, delimiter/token
// will conflict over ( and ). that's the parser's job.

// lexer can process non-terminal one level deep? we could do
// <atmosphere> -> <whitespace> | <comment> here, for instance

// how do we deal with the fact that e, s, f, d, l and both exponent
// markers and letters; they'll lex as an arbitrary rule; or can we
// combine rules? hmm: letter takes precedence over exponent_marker,
// whether first or last.

// make the suffix rule a complex reg that only matches the
// combination of terminals

// shit: how to modify the regexps to be non-case sensitive; all the
// fucking identifiers are going to be case-sensitive: /.../i doesn't
// work; /(?i).../ doesn't work. not really pregs, then. fuck: it's
// doing it's own regex parsing; bastard.

// going to have to capture the lexemes with complex regexps; keywords
// will still be case sensitive, though

// or maybe a reasonable granularity are the tokens

// ignore case sensitivity for now; assume we have to modify lexer to
// account for it

// use lexer as a strict terminal -> token mechanism

// instead of sed on the resultant php, allow modifiers through:
// imsxUX: /.../[imsxUX]

// letter = /[a-zA-Z]/
// letter {
//   $this->token = Parser::LETTER;
// }

/*
octothorpe = /\#/
octothorpe {
  $this->token = Parser::OCTOTHORPE;
}
*/
// find expressions for {{+,-},ureal} in the various bases; digest
// complex into eight parts per base plus +i -i for all bases
// (positive_imaginary, negative_imaginary)

/*!lex2php
%input $this->data
%counter $this->count
%token $this->token
%value $this->value
%line $this->line
open = /\(/
close = /\)/
open_vector = /\#\(/
quote = /\'/
quasiquote = /\`/
unquote = /\,/
unquote_splicing = /\,\@/
whitespace = /( |\n)/
comment = /;.*/
slash = /\//
special_initial = /(\!|\$|\%|\&|\*|\:|\<|\=|\>|\?|\^|\_|\~)/
digit = /[0-9]eouhtneoutnh/
positive = /\+/
negative = /\-/
dot = /\./
ellipsis = /\.\.\./
asperand = /\@/
semicolon = /\;/
syntactic_keyword = /(else|\=\>|define|unquote|unquote-splicing)/
expression_keyword = /(quote|lambda|if|set\!|begin|cond|and|or|case|let|let\*|letrec|do|delay|quasiquote)/
true = /\#t/
false = /\#f/
character = /(\#\\.|\#\\(space|newline))/
string = /\"([^\"\\]|\\\"|\\\\)*\"/
inexact = /\#i/
exact = /\#e/
binary = /\#b/
octal = /\#o/
decimal = /\#d/
hexidecimal = /\#x/
letter = /[ghjkm-rt-z]/
a = /a/
b = /b/
c = /c/
d = /d/
e = /e/
f = /f/
i = /i/
l = /l/
s = /s/
zero = /0/
one = /1/
two = /2/
three = /3/
four = /4/
five = /5/
six = /6/
seven = /7/
eight = /8/
nine = /9/
*/

/*!lex2php
open {
  $this->token = Parser::OPEN;
}
close {
  $this->token = Parser::CLOSE;
}
open_vector {
  $this->token = Parser::OPEN_VECTOR;
}
quote {
  $this->token = Parser::QUOTE;
}
quasiquote {
  $this->token = Parser::QUASIQUOTE;
}
unquote {
  $this->token = Parser::UNQUOTE;
}
unquote_splicing {
  $this->token = Parser::UNQUOTE_SPLICING;
}
whitespace {
  $this->token = Parser::WHITESPACE;
}
comment {
  $this->token = Parser::COMMENT;
}
special_initial {
  $this->token = Parser::SPECIAL_INITIAL;
}
digit {
  // $this->token = Parser::DIGIT;
  $this->token = 'shit';
}
positive {
  $this->token = Parser::POSITIVE;
}
negative {
  $this->token = Parser::NEGATIVE;
}
dot {
  $this->token = Parser::DOT;
}
ellipsis {
  $this->token = Parser::ELLIPSIS;
}
asperand {
  $this->token = Parser::ASPERAND;
}
syntactic_keyword {
  $this->token = Parser::SYNTACTIC_KEYWORD;
}
expression_keyword {
  $this->token = Parser::EXPRESSION_KEYWORD;
}
true {
  $this->token = Parser::TRUE;
}
false {
  $this->token = Parser::FALSE;
}
character {
  $this->token = Parser::CHARACTER;
}
string {
  $this->token = Parser::STRING;
}
inexact {
  $this->token = Parser::INEXACT;
}
exact {
  $this->token = Parser::EXACT;
}
binary {
  $this->token = Parser::BINARY;
}
octal {
  $this->token = Parser::OCTAL;
}
decimal {
  $this->token = Parser::DECIMAL;
}
hexidecimal {
  $this->token = Parser::HEXIDECIMAL;
}
a {
  $this->token = Parser::A;
}
b {
  $this->token = Parser::B;
}
c {
  $this->token = Parser::C;
}
d {
  $this->token = Parser::D;
}
e {
  $this->token = Parser::E;
}
f {
  $this->token = Parser::F;
}
i {
  $this->token = Parser::I;
}
l {
  $this->token = Parser::L;
}
s {
  $this->token = Parser::S;
}
letter {
  $this->token = Parser::LETTER;
}
zero {
  $this->token = Parser::ZERO;
}
one {
  $this->token = Parser::ONE;
}
two {
  $this->token = Parser::TWO;
}
three {
  $this->token = Parser::THREE;
}
four {
  $this->token = Parser::FOUR;
}
five {
  $this->token = Parser::FIVE;
}
six {
  $this->token = Parser::SIX;
}
seven {
  $this->token = Parser::SEVEN;
}
eight {
  $this->token = Parser::EIGHT;
}
nine {
  $this->token = Parser::NINE;
}
*/
}

function token_array($lexer) {
  $tokens = NULL;
  foreach ($lexer as $token => $value)
    $tokens[] = array($token => $value);
  return $tokens;
}
